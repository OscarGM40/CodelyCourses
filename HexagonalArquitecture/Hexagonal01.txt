

Repo: https://github.com/CodelyTV/frontend-hexagonal_architecture-course/tree/main/01-hexagonal_architecture_in_frontend/1-hexagonal_architecture_in_10_minutes

La arquitectura hexagonal es un patr贸n de arquitectura de software que nos ayuda a tener un codigo mantenible,escalable y testeable.Esta englobada en las denominadas 'arquitecturas limpias' que se caracterizan por separar la l贸gica de nuestro dominio de la capa de infraestructura o aplicaci贸n.
Se debe acompa帽ar de Vertical Slicing y Screaming Architecture

Se compone de tres capas:
La capa de infraestructura: esta capa contiene los detalles de implementaciones concretas,como las llamadas a una API, bases de datos,... cualquier cosa que toque entrada y salida
La capa de aplicaci贸n: esta capa se encarga de la comunicaci贸n entre la capa de dominio y el mundo exterior,lo que denominamos casos de uso (crear un usuario,hacer login,hacer logout,...)
La capa de dominio: es la capa m谩s importante, contiene la l贸gica de negocio central de la aplicaci贸n,y define las reglas de negocio. No depende de ninguna otra capa y puede contener cosas como tipos,interfaces o funciones de validaci贸n(aqui habr谩 conceptos como un User, un Id o cualquier ValueObject e incluso las interfaces de nuestro repositorio,fijate que todo esto es para tipar).
Las dependencias deben apuntar hacia el interior de las carpetas(es decir,las capas inferiores deben definir las interfaces que las capas superior puedan usar/reclamar)

TIP: estas capas van acompa帽adas de una regla de dependencia que va desde fuera hacia adentro(la de afuera depende/conoce a las de dentro).Es decir,infraestructura puede conocer detalles de aplicaci贸n o dominio, aplicaci贸n puede conocer detalles de dominio pero no de infraestructura y dominio solo puede conocerse a si misma.B谩sicamente esto se traduce en que desde dominio nunca voy a poder importar ni aplicaci贸n ni infraestructura y desde aplicaci贸n nunca podr茅 importar infraestructura(pero si a ella y a dominio ) y obviamente infraestructura puede importar lo que quiera.

NOTA: el h茅xagono se puso por que tiene muchos lados y picos,pero carece de sentido que sea un hex谩gono.Es mucho m谩s acertado usar el nombre de "Puertos y Adaptadores".
IMPORTANTE: todo esto al final se traduce en una estructura de carpetas a la hora de arquitecturar una aplicaci贸n de software.Habr谩 tres carpetas principales( 'application', 'domain' e 'infrastructure') de las que colgaria todo.

NOTA: si aplicamos arquitectura Hexagonal por si sola no vamos a conseguir esa clean arquitecture que queremos. Aqui entra el concepto de Vertical Slicing en juego,ya que obviamente que cuelgue todo de 3 carpetas va a quedar una aplicaci贸n inmantenible.

Vertical Slicing: consiste en dividir el sistema en funcionalidades verticales completas,que atraviesan todas las capas de la arquitectura hexagonal (no es m谩s que imaginarme el hex谩gono(o circulo) de la arquitectura hexagonal como si fuera un pastelito que puedo cortar. Cada trozo va a representar una entidad o agregado (un conjunto de caracteristicas que proporcionan un valor tangible al usuario y que se implementa de forma independiente),en resumen, algo que tenga sentido para negocio.Por ejemplo Courses,Teachers,Students,Products,etc...

Ojo, la entidad va primero, y dentro de cada entidad van las 3 capas:

app/
|_Courses/ <- Entidad
  |_application/  <- capas
  |_domain/
  |_infrastructure/
|_Teachers/ <- Entidad
  |_application/ <- capas
  |_domain/
  |_infrastructure/

Tmb hay gente que lo hace al rev茅s,deja las 3 capas afuera y dentro segrega por Entidades.Desde Codely creen que es un error esta forma de usar Vertical Slicing. Esto me parece un error a mi tmb,ya que queda m谩s claro cuando estas trabajando que tienes que crear una nueva Entidad y luego ya iras rellenando las capas

TIP: invertir las dependencias normalmente significa pasar un repositorio por par谩metro(fijate que lo har茅 en React).Pegar un repaso a este principio.

IMPORTANTE: usar la forma de primero entidades,y cada una con sus tres capas me permitiria solo con arrastar esa carpeta pasar todo ese 'bloque'.Esta forma deja un c贸digo m谩s cohexionado y mantenible(lo mismo si ya no tuviera Courses borro una carpeta solo).Con la forma segunda habr谩 referencias cruzadas,etc y tendr茅 que ir por cada capa.

Screaming arquitecture(arquitectura que te grita al careto): porqu茅 necesito esto tmb? Porque dentro de la capa las cosas podr铆an ir creciendo m谩s(lo har谩n de echo).Entonces podemos aplicar el mismo concepto de vertical slicing dentro de la capa(por ejemplo dentro de la entidad/agregado Auth tengo los casos de uso de login/register y de logout,me quedar铆a algo asi:)

app/
  |_Auth/
    |_application/
      |_logout/ <- Screaming arquitecture
      |_login/ <- Screaming arquitecture
      |_register/ <- Screaming arquitecture
    |_domain/

La navegabilidad del c贸digo es brutal.Si la aplicaci贸n es muy peque帽a podria valerme con Vertical Slicing,pero a la que crezca es indispensable usar Screaming Arquitecture tmb
NOTA: la Screaming Arquitecture se llama asi porque nos est谩 "gritando" que somos un logout o un login,no que somos un ComandHandler o un ExpectionHandler que realmente no s茅 lo que es(adem谩s de nuevo esto no favorece la cohexi贸n sino que la rompe).Desde luego tiene toda la pinta de que tener un front con arquitectura hexagonal      

Notas de gente desconocida random:
Lo del nombre de hexagonal yo siempre hab铆a o铆do que era por el tema de que cada hex谩gono se conecta con otros a trav茅s de los puertos y adaptadores y si pones varios hex谩gonos las figuras se acoplan bien (vamos, que el concepto viene del plano visual) <- pues tiene bastante sentido,claro que podria estar inventandoselo

      VIDEO 02 HAY LOGICA DE NEGOCIO EN FRONT??

Tradicionalmente la arquitectura hexagonal siempre se ha aplicado en el backend.Sin embargo,en los ultimos a帽os ciertas aplicaciones si que pasan l贸gica al frontend,por ejemplo GitHub(en el caso de uso de crear una Issue,el front se asegura de que no se pueda crear una issue sin titulo).Aunque se valide en el backend,esta l贸gica vive tambi茅n en el frontend.
Nuria y el pelanas explican muy bien que incluso hay interrelaci贸n con un dominio User,ya que tenemos que asignar la issue a un User, y ojo, no es lo mismo el User de la cuenta de GitHub({id:"sfsf",username:"rgomez",image_url}) que tiene 3 propiedades que el User al que hay que asignar(o resultante de asignar) la issue, que tendr谩 m谩s propiedades.

Podria parecer que podemos crear una interface con campos nullables segun tenga una issue o no,pero nos obligaria a a帽adir m谩s condiciones y lo hace complicado de mantener:

export interface User {
    id: UUID;
    username: string;
    imageUrl: URL;
    name: string | null;
    status: string | null;
}

Desde Codely recomiendan crear interfaces distintas:

export interface User {
    id: UUID; <- fijate ya en los Value Objects
    username: string;
    imageUrl: URL;
}

export interface Assignee {
  id: UUID;
  username:string;
  imageUrl: URL;
  name: string;
  status: string;
}
Este tipo de decisiones son las que les hacen inclinarse por decir que si que hay l贸gica en el frontend
IMPORTANTE: fijate como las interfaces User,Asignee o Issue ser铆an de la capa del dominio, pero la interface CreateIssue que es para el caso de uso es de la capa de aplicaci贸n
NOTA: tmb recalcan que el framework a usar pertenece a la capa de infraestructura por naturaleza,pero esto es realmente asi? Debe pertenecer a esa capa?

    VIDEO 03 COMO ENCAJAN REACT,VUE,ANGULAR,... O CUALQUIER FRAMEWORK CON LA ARQUITECTURA HEXAGONAL

Al usar arquitectura hexagonal se busca separar la l贸gica de negocio de la l贸gica de UI(mostrar/ocultar elementos,tratar con inputs,...)
Si separamos la aplicaci贸n en 3 capas me quedar谩 la duda de si esta l贸gica de UI que es de la que se encarga el framework es dominio,aplicaci贸n o infraestructura
Podriamos considerarlo infraestructura ya que el framework es una dependencia externa.Pero como ver茅 m谩s adelante, durante el testing ser谩 nuestro punto de entrada en los test unitarios,algo que tradicionalmente ha sido la capa de aplicaci贸n.
Adem谩s,las peculiaridades de los frameworks a menudo nos pueden limitar la estructura de nuestra aplicaci贸n, por ejemplo, forzando que haya un fichero main.ts dentro de la carpeta src

En cuanto a un ejemplo en React diriamos que la View es infraestructura,sus componentes y casos de uso son aplicaci贸n.En la implementaci贸n/desarrollo de esos casos de uso necesitar茅 objetos de dominio(un Repository,un User,etc) que obviamente son de la capa de dominio.Fijate que la implementaci贸n de ese Repository es de la capa de infraestructura(esto no lo pillo bien)
Y en cuanto a la estructura de carpetas en una aplicaci贸n de React,si bien podriamos hacer eject, prefieren aceptar que vendr谩 todo dentro de 'src' y despues parece que abren dos carpetas llamadas 'modules' y 'sections'.En modules es donde va a estar toda la l贸gica.En sections parece que van todos los componentes y ser铆a la capa de application.
Parece muy confuso e interpretable todo,mejor no sacar opiniones sobre esto y amoldarme al proyecto y al equipo de front correspondiente

NOTA IMPORTANTE: Error conceptual de arquitectura hexagonal
En mi opini贸n, considerar componentes y hooks de React como parte de la capa de aplicaci贸n es un error conceptual que viola lo que plantea esta arquitectura, ya que en lugar de hacer la aplicaci贸n escalable del lado de la UI permitiendo cambiar la librer铆a de Resct a Vue o a Svelte (agn贸stico del franework) se est谩 acoplando al mismo.

Aunque Rafa lo aclara varias veces diciendo que esta hecho a sabiendas (lo cual es positivo) y ha sido una decisi贸n del equipo de Codely, partir de este ejemplo que viola el principal principio de la arquitectura hexagonal en un curso sobre esta arquitectura, creo que es contraproducente.

Sinceramente esperaba m谩s del curso.Parece que React nunca debi贸 salir a la capa de aplicaci贸n en esa carpeta sections
Ojo, aun quedan m谩s carpetas como shared o commons y fijate que cada uno est谩 viendo la estructura de archivos como le da la gana.Simplemente tomarlo como una intro todo esto.Por 煤ltimo, usar arquitectura hexagonal debe ser una decisi贸n que beneficie al proyecto.

        VIDEO 04 PRIMER EJEMPLO EN CODIGO

NOTA: fijate que los puntos de entrada index.tsx o App.tsx los consideran arquitectura.Fijate tmb como consideran que los hooks son application(aunque est茅 contaminado por arquitectura)
Recuerda que puedo hacer typeof instance_of_an_object para que ese objeto me haga de tipo

Asi pues me descargo el repo(lo crear茅 de 0).Vamos a crear un caso de uso(la creaci贸n de un curso).Tendr茅 un componente de React que se encarga de pintar el formulario, los errores de validaci贸n,etc.Este componente a su vez usar谩 un hook para gestionar el estado,pero todo esto vivir谩 en mi aplicaci贸n de React,esto no es importante,lo que importa ahora es como gestionar la l贸gica de negocio y como guardar茅 el curso(tras crearlo supongo)

Habr谩 que crear una interfaz que defina como va a ser un curso(en este caso dentro de modules/courses <- fijate la Screaming Arquitecture aqui) y ya dentro de courses en la carpeta domain:

export interface Course {
	id: string;
  title: string;
  imageUrl: string;
}

Ahora ya puedo crear el caso de uso(la tipica funcion create,que tendr谩 que ir en modules/courses/application/create <- de nuevo Screaming Arquitecture(la primera lo era??))

export function createCourse(course: Course): void { }

Fijate que si uso arquitectura hexagonal no puedo importar aqui axios,o cualquier fetcher,si no estaria metiendo la infraestructura dentro de aplicaci贸n.
NOTA: muchas veces en estas funciones,que es el service ya se llama al fetcher,pero se puede ir un paso mas all谩 y desacoplar esto,esta vez mediante el patr贸n Repository

  VIDEO 05 DESACOPLANDO EL SERVICIO O MTODO PARA NUESTRO CASO DE USO

El patr贸n Repository permite desacoplar implementaci贸n y l贸gica de la persistencia de datos.
Por tanto tende una interfaz CourseRepository que traiga todos los cursos,guarde uno,traiga uno,borre uno etc y despues tendr茅 varias implementaciones posibles(una que guarde a una DB,otra al localStorage,otra mediante axios,etc)
Todas estas implementaciones tocan entrada y salida de datos,asi que son infraestructura.

NOTA:esta interface Repository recuerda que es del dominio.Podria ser algo asi:

En /modules/course/domain/CourseRepository.ts
import { Course } from "./Course";

export interface CourseRepository {
	save: (course: Course) => void;
	getAll: () => Course[];
}

IMPORTANTE: para hacer la inversi贸n de dependencias como no tengo clases en funciones simplemente se pasan por par谩metro.Fijate que interesante esto:

export function createCourse(courseRepository: CourseRepository, course: Course): void {
	courseRepository.save(course);
}

NOTA: la gracia de la inyecci贸n de dependencias es tener la inversi贸n de dependencias.Lo secundo.Fijate que nuestro ContextProvider va a recibir por props un repository:


export const CoursesContextProvider = ({
	children,
	repository, <- necesitamos la instancia
}: React.PropsWithChildren<{ repository: CourseRepository }>) => {
	const [courses, setCourses] = useState<Course[]>([]);

	function create({ title, imageUrl }: { title: string; imageUrl: string }) {
    // fijate como ahora es trabajo del front crear el id
		const id = (uuidv4 as () => string)();
		createCourse(repository, { id, title, imageUrl });
	}

  En el App.tsx(que es infraestructura) instanciamos el repo para los cursos(de tipo CourseRepository):

  export function App() {
	const repository = createLocalStorageCourseRepository();

	return (
		<CoursesContextProvider repository={repository}>
			<div className="App">
				<h1> Codely</h1>
				<CoursesList />
				<CreateCourseForm />
			</div>
		</CoursesContextProvider>
	);
}

NOTA: la inversi贸n de dependencia es la D de solid
En este ejemplo sencillo con React queda claro que App.tsx es el encargado de inyectar una implementaci贸n concreta, pero y si son muchas?
Un usuario implementa su arquitectura algo distinto a ellos.Decidi贸 que en su infra iba a tener las vistas que si o si ser铆an reemplazables(por si cambian de React a Vue,etc).A nivel de esas carptetas tiene otra que se llama injections donde hace las instancias a todas estas funciones(el const repository = createLocalStorageRepository() del App.tsx)
En los componentes o vistas usa un composable/hook que llama a la inyecci贸n que ya pueden usar los casos de uso(puede ser un hook o un provide inject,no necesariamente deben ir en app.vue,pueden ir en cualquier pagina que los requiera)
Otro usuario parece que dice lo mismo que ser铆a una carpeta /provide/inject.Todo esto parece un tanto confuso

Desde luego puedo apreciar lo limpio que queda inyectar el repositorio hacia la capa de aplicaci贸n

    VIDEO 06 AADIR VALIDACIONES AL CASO DE USO. COMO Y DONDE

Un dilema importante es donde tener las validaciones.Desde luego el back tiene que tenerlas,esto esta claro. Veamos nuestro caso de uso de crear un curso si tmb necesita de ellas.

Ya de momento recalca Nuria que deberiamos tener dos validaciones ya en el front, que la url de la imagen sea una url v谩lida y la longitud del t铆tulo del curso.Adem谩s queremos que mientras el usuario escribe ya le salten las validaciones.

IMPORTANTE: esta funci贸n es una regla de nuestro dominio(aunque la llamar茅 en apliccation/casoDeUso).Y dado que valida un curso va en domain/course.ts:

NOTA: vamos a lanzar excepciones en vez de un boolean que nos diga si el curso es valido luego la funcion validadora retornar谩 void;

TIP: fijate como regexp.test(expresion) me devuelve un boolean y con ello puedo hacer if(!function):

export function isCourseIdValid(id: string): boolean {
	const regexExp =
		/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;

	return regexExp.test(id);
}

En este punto Rafa recalca que podria tener todas las validaciones en un file(obviamente siempre van a ir en dominio,pero podria haber echo todo en un file).Lo bueno de tener todo separado por propiedades es que es mucho m谩s f谩cil de cohexionar las cosas.Lo importante es que est茅 en dominio,b谩sicamente
NOTA: fijate que podria usar su expresion regular
Bien,todo esto me queda bien claro de porqu茅 se hace y donde se hace.Pero a煤n nos falta la validaci贸n en tiempo real(experiencia de usuario),pues no queremos que sea mando el form,veo el error

Un simple efecto valdr谩,fijate que las funciones est谩n en dominio pero para poder usarlas en aplicaci贸n o infraestructura perfectamente:

	useEffect(() => {
		const isTitleValid = isCourseTitleValid(formData.title);
		const isImageUrlValid = isCourseImageUrlValid(formData.imageUrl);
		setErrors({
			title: isTitleValid
				? ""
				: `Title must be between ${TITLE_MIN_LENGTH} and ${TITLE_MAX_LENGTH}`,
			imageUrl: isImageUrlValid ? "" : `Image url is not valid`,
		});
	}, [formData.imageUrl, formData.title]);

TIP: fijate que ellos tienen el caso de uso de getAllCourses(fijate que es un caso de uso,quiero decir,asinto)

new Map<T,R> <- crear un map
map.set(clave,valor)
map.get(clave)
map.has(clave)
map.delete(clave)
map.clear() elimina todo el Map
map.size <- propiedad igual que length en arrays

NOTA: Map utiliza comparaci贸n estricta(===) para comparar las keys
TIP: cada llamada a map.set(clave,valor) devuelve el map asi que puedo encadenarlos:
map.set('1','anything')
   .set('2','otra cosa').set('3','3')......

Para recorrer un Map hay tres m茅todos, map.keys() devuelve un Iterable con las llaves,map.values() devuelve un iterable con los valores y map.entries() devuelve un iterable con un arreglo [key,value].
Ojo, Map guarda el orden de inserci贸n,luego guarda un Mapa ordenado

Conversiones: si tengo un objeto puedo pasarlo a Map(y viceversa) muy f谩cil:
let obj = {
  name: "John",
  age: 30
}
let map = new Map(Object.entries(obj))

El m茅todo Object.fromEntries hace lo contrario, dado un array de pares[clave,valor] crea un object a partir de ese array
let prices = Object.fromEntries([
  ['banana',1],
  ['orange',2],
  ['meat',4]
])

Diria que un Map es muy interesante para guardar Articulos con su precio,etc,aunque normalmente dos propiedades se quedan escasas(si que seria m谩s interante que el valor fuera un object)

Filtrar miembros 煤nicos de un array.Recuerda que puedo hacer esto con un Set:

function unique(arr) {
  return Array.from(new Set(arr)) <- y a mimir
}

let values = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];
Un DTO es una clase que solo contiene datos para poder ser pasados entre capas(sanitizar = sanitize)

    VIDEO 07 DONDE EMPIEZAN Y ACABAN LOS TEST UNITARIOS

Ellos consideran que un Unit test empieza en el Component(Application) , abarca el useCase(Application) y el Repository(Domain), pero la implementaci贸n de ese Repository(arquitecture) se har谩 con un mock y por ello solo abarca App y domain

Un test de integraci贸n si que va a implementar el Repository(por ejemplo una implementaci贸n del localStorage o del Store)Ver imagen.

NOTA: normalmente estas implementaciones del Repository suelen ser asincronas, o m谩s pesadas,etc.Es algo que queremos evitar en el testing y por eso es recomendable hacer unit testing mockeando la implementaci贸n del Repository(Store,etc).Interesante

En el mundo real el test m谩s importante es el test de aceptaci贸n(o test end to end) que es el que cubre todo.Lo malo es que son los mas lentos y los que m谩s trabajo requieren

En nuestro caso el componente ser铆a el componente que llama al formulario para crear un form

        VIDEO 08 IMPLEMENTANDO EL TESTING UNITARIO

Lo primero recuerda crear el setupTests.ts(en plural) a la altura de /tests/setupTests.ts.
Fijate que est谩n empezando desde el Context.Recuerda que Nuria tiene raz贸n en decir que la entrada al localStorage es sincrona.

Fijate en el acierto de buscar por label en vez de por text en cuanto pueda

Fijate que al pasar un objeto que cumple la interfaz puedo hacer spy sobre la funcion.Este concepto no lo tenia muy claro,ya que con jest.fn() puedo saber si se ha llamado y con que se ha llamado,es m谩s potente de lo que me parec铆a:

describe("CreateCourseForm with mocked API", () => {
	it("displays success message when data is correct", async () => {
		const save = jest.fn();
		render(
			<CoursesContextProvider
				repository={{
					save,
					get: jest.fn(),
					getAll: jest.fn(),
				}}
			>
				<CreateCourseForm />
			</CoursesContextProvider>
		);
		const titleInput = screen.getByLabelText(/title/i);
		userEvent.type(titleInput, "Awesome Hexagonal Architecture");

		const imageUrlInput = screen.getByLabelText(/image/i);
		userEvent.type(imageUrlInput, "http://placekitten.com/500/400");

		const submitButton = screen.getByText(/create course/i);

		userEvent.click(submitButton);

		const successMessage = await screen.findByRole("heading", { name: /Course created/i });
		expect(save).toHaveBeenCalled();
		expect(successMessage).toBeInTheDocument();
	});

  Monorepo con el backend(entiendo que es un repo con el front y el back en la misma carpeta).Podrian compartir las entidades de dominio entonces?<- si es posible seria ideal ?? Investigar

      VIDEO 09 TEST DE INTEGRACION Y END TO END(ACEPTACION)

Preguntar a Miguel porque se llama testing de aceptaci贸n.
Fijate que al usar cypress voy a necesitar ya el archivo cypress.config.ts:

import { defineConfig } from "cypress";

export default defineConfig({
	video: false,
	e2e: {
		baseUrl: "http://localhost:3000",
		specPattern: "tests/e2e/tests/**/*.spec.{js,jsx,ts,tsx}",
		screenshotOnRunFailure: false,
		video: false,
		viewportWidth: 1920,
		viewportHeight: 1080,
		supportFile: "tests/e2e/support/e2e.ts",
	},
});

Para el testing tmb vamos a tener los scripts siguientes:
   "test": "jest",
    "cy:open": "cypress open",
    "cy:run": "cypress run"

Fijate que tmb tengo los del linter y que tengo todo en el README

Cypress es una libreria que levanta un navegador y nos permite ejecutar los test en un entorno 100% real.
Jest no implementa la API fetch y ellos prefieren usar un entorno real.Me interesa mucho usar cypress,etc

NOTA: fijate que la configuraci贸n de cypress no termin贸 en el file en el root,sino que hay que crear una carpeta 'e2e-integration' con una subcarpeta 'support' y el file e2e.ts y commands.ts


/* eslint-disable testing-library/prefer-screen-queries */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable testing-library/await-async-query */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
describe("The home page", () => {
	it("creates a course when filling up the form correctly", () => {
		cy.visit("/");
		cy.findByLabelText(/Course title/i).type("Awesome Hexagonal Arquitecture");
		cy.findByLabelText(/Image URL/i).type("http://placekitten.com/500/400");
		cy.findByText(/create course/i).click();
		cy.findByRole("heading", { name: /Course created/i }).should("exist");
		cy.findByRole("heading", { name: "Awesome Hexagonal Architecture" }).should("exist");
	});
});

Fijate que cypress es sencillisimo y que se parece mucho al test unitario.Fijate tmb que estamos testeando la pagina entera y que es un test m谩s completo o fiable que los que pueda hacer yo(sin desmerecerlos)

Interesante el format del console.log(tiene que ser %d y %s en este orden o what??):
const server = app.listen(app.get("port"), () => {
	console.log(
		"  App is running at http://localhost:%d in %s mode",
		app.get("port"),
		app.get("env")
	);
	console.log("  Press CTRL-C to stop\n");
});

export default server;

Fijate tmb como han usado chai para promesas:
import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { v4 as uuidv4 } from "uuid";


chai.use(chaiAsPromised); <- linea importante
const expect = chai.expect; <- economizar siempre es bueno,asinto

it("does not throw an error when creating a course", () => {
	const repository = createApiCourseRepository();
	return expect(
		repository.save({
			id:uuidv4(),
			title: "Course title",
			imageUrl:"http:///placekitten.com/500/400"
		}).to.be.fulfilled
	)
})

Test de integraci贸n contra una API.Los tests de integrac铆on son los mas prescindibles,ya que el endToEnd garantiza ya la integraci贸n contra la API(si no no ver铆amos una mierda) y los de integraci贸n son practicamente igual de lentos,ya que tienen que hacer las peticiones.

Y para los test e2e playwright ya viene con msw integrado y es super friendly. Que es PlayWright y MSW?

				VIDEO 10 PASAR DE jQuery a Hexagonal

Nuria y Rafa muestran un c贸digo legacy superacoplado con todo en un archivo.Por ejemplo estamos mezclando validaciones(dominio) con el acceso al localStorage(architecture con ch,asinto) y todos los casos de uso(application)
Tambi茅n muestran el testing,y como hay un 煤nico test end to end ya que al tener todo en un archivo es imposible hacer test unitarios

Antes de hacer refactor hay que ejecutar el test y ver que funcionaba correctamente lo que voy a refactorizar,ojo!

Esto nos permite invertir las dependencias pasando el repositorio por par谩metro, para poder as铆 desacoplarnos de la implementaci贸n concreta. Inversi贸n de dependencias(Dependency Inversion) la I es Interface Segregation(usa el ingl茅s y sale solo)
Para no llamar directamente desde el main con el Repository lo que se hace es crear los casos de uso,que reciben un repositorio y lo guarda(sin saber como).Es aqui donde esta el desacoplado,no llamo al localStorage directamente sino que lo paso por el caso de uso

			VIDEO 11 CASOS DONDE NO HACE FALTA USAR HEXAGONAL

Muestran una aplicaci贸n bastante parecida a la nuestra, con un archivo para el modelo y las validaciones y otro para los servicios(con las implementaciones concretas).Obviamente hay algo de acople en los servicios

Fijate en el testing como jest.mock("path") lo que hace es interceptar el import y despues mockear esa funci贸n a lo que yo quiera:

import { saveCourse } from "../../courses/shared/coursesService"; <- import normal

lo intercepto(pero han interceptado todo el modulo...)
jest.mock("../../courses/shared/coursesService");
const savedCourseMock = saveCourse as jest.Mock<Promise<void>>; <- saveCourse es el mock

  describe(....,() => {
		saveCourseMock.mockResolvedValueOnce() <- me faltaba decir que devuelve
	})

Mirar nuestra sintaxis.Fijate que aqui no hay inversi贸n de dependencias,pues el servicio usa implementaciones concretas.Sin embargo recalcan que no es un mal approach

Vemos as铆 que lo que nos aporta Hexagonal es:
1- Un framework mental para trabajar en equipo
2- Separaci贸n m谩s clara por carpetas/capas
3- Posibilidad de a帽adir reglas de linter para controlar regla de dependencias (eslint-plugin-hexagonal-architecture) Este linter controla que desde dominio no pueda hacer imports de application,etc.Tmb fuerza el naming de las carpetas.

Sigo teniendo dudas de cuando ir铆a bien hexagonal,entiendo que si no va a haber modificaciones no hace falta,pero si va a haber cambio de frameworks(como pueda haber con microfrontends) si que parece indispensable dominarlo.
NOTA: Hexagonal agrega niveles de indirecci贸n,es algo que hay que tener en cuenta

				VIDEO 12 PROMESAS Y HEXAGONAL

Podriamos definir una promesa como un detalle de implementaci贸n que nos est谩 diciendo que algo va a ser as铆ncrono en vez de s铆ncrono.Deber铆a de ser infraestructura,ya que estamos tocando entrada y salida pero en Javascript esto es dificil de ver 

Nuria y el pelanas muestran un ejemplo donde tenemos una implementaci贸n de CourseRepository(recuerda,la implementacion va en infraestructura,la definicion de la interfaz o la abstraci贸n va en el dominio).En realidad tenemos dos,la ya vista del localStorage y otra usando la api fetch que obviamente nos hace cambiar el tipado de la interfaz:

export interface CourseRepository {
	save: (course: Course) => void | Promise<void>;
	get: (id: string) => Course | null | Promise<Course | null>;
	getAll: () => Course[] | Promise<Course[]>;
}

Usar los union types puede parecer el Santo Grial, ya que resuelve los problemas de tipado,pero en el momento de consumir/implementar la abstracci贸n vamos a tener el mismo problema,que no va a saber si es uno u otro y hay que manejar ambas posibilidades.
Entiendo que se decantaron por usar union types

				VIDEO 13 OBJECT MOTHER en testing

El patr贸n Object Mother nos ayuda a simplificar y agilizar la creaci贸n de datos fake en nuestros test.Si nos fijamos en el test del video:

const titleInput = screen.getByLabelText(/title/i);
userEvent.type(titleInput, invalidTitle);

const errorMessage = await screen.findByText("Title must be between 5 and 100 characters");

vemos que hay literales calzados a pelo ahi.Esto no es buena idea,empeora la legibilidad
Para solucionar este problema puedo usar el patr贸n Object Mother (tmb conocido como Test Object Factory ??).

Usaremos dos librerias(@faker-js/faker y fishery).Fishery es una dependencia que me permite agilizar todas estas funciones de tipo factoria para generar objetos:

import { faker } from "@faker-js/faker";
import{ Factory } from "fishery";

import { Course } from "../../domain/Course"; <- me traigo el model
import { TITLE_MAX_LENGTH, TITLE_MIN_LENGTH } from "..."

const courseFactory = Factory.define<Course>(() => ({
	id: faker.datatype.uuid(),
	title: faker.lorem.sentence(),
	imageUrl: faker.image.imageUrl(),
}))

Para no acoplarnos tampoco a la libreria esta de Factory exportamos nuestro objeto que fijate que tiene las propiedades create,createList,createWithTooShortTitle,etc <-obviamente son propiedades que nos inventamos,lo bueno est谩 en su valor:

export const CourseMother= {
	create: (params?:Partial<Course>):Course => {
		return CourseFactory.build(params)
	},
	createList: (length = 5): Course[] => {
		return CourseFactory.buildList(length)
	},
	createWithTooShortTitle: ():Course => {
		return CourseFactory.build({
			title.faker.lorem.word(TITLE_MIN_LENGTH - 1)
		})
	}
}

Fijate como ellos ya saben la sintaxis de Factory.define<T>(callback)
y que despues pueden llamar al retorno de esta funcion y sus propiedades .build o .buildList(number) para generar incluso varios cursos.

Pero tambi茅n puedo apreciar como han usado Vertical Slicing + Hexagonal y han metodo el CourseMother en la carpeta domain del agregado.Te cagas

Ahora si, ya podemos usar este objeto madre en los testing:

it("displays error message if title is too long",async() => {
	const repository = createLocalStorageCourseRepository();
	const { title: invalidTitle } = CourseMother.createWithTooShortTitle();

	render(
			<CoursesContextProvider repository={repository}>
				<CreateCourseForm />
			</CoursesContextProvider>
	)

  const titleInput = screen.getByLabelText(/title/i);
	userEvent.type(titleInput,invalidTitle);
// fijate en el await screen.findByText, pero si nosotros lo usamos sin await,no ?	
	const errorMessage = await screen.findByText("Title must be between 5 and 100 characters")

	expect(errorMessage).toBeInTheDocument();
})

Desde luego tiene buena pinta.Nuria recalca que tienen un curso de testing en front.Creo que es muy buena idea hacerlo mientras me acoplo a mi nueva empresa

NOTA: m谩s all谩 de tener mayor agilidad a la hora de crear datos para mis tests,la aleatoriedad de esa generaci贸n tambi茅n nos aporta robustez y fiabilidad,ya que no estar茅 siempre testeando con los mismos valores
Otro beneficio del patr贸n Object Mother es que mejora la legibilidad de nuestros tests. Al utilizar objetos que representan conjuntos de datos, el c贸digo se vuelve m谩s conciso y f谩cil de entender.Concuerdo con sus afirmaciones

La libreria faker es un standar de facto para fakear datos.

			VIDEO 14 COMO USAR LA CARPETA SHARED

El m贸dulo shared, tambi茅n llamado commons contiene funciones geneicas que reutilizamos y llamamos desde distintos m贸dulos/partes de nuestra aplicaci贸n.
Creando est茅 modulo evitamos la duplicidad y mejoramos la mantenibilidad de nuestro c贸digo.Sin embargo hay ciertas reglas que hay que tener en cuenta.

No es bueno crear interfaces a medias,que usen dos interface que ya tenemos para evitarnos crear dos y crea una gen茅rica en shared.Esto me va a dar problemas a la larga,ya que tendr茅 problemas para testear o escalar esa interface(diria que lo importante no es que vaya en shared,sino que no debo hacer eso y debo crear types para cada caso de uso,etc)

Shared si que me puede ser muy 煤til para evitar duplicar c贸digo y simplificar ciertas partes.Para asegurarme que no se me va de las manos,deber铆a seguir estas reglas:

1- Solo compartir茅 dos capas,dominio e infraestructura, nunca casos de uso
2- La regla de 3, solo deber铆a mover c贸digo a shared cuando se haya duplicado m谩s de dos veces(a la tercera que lo vaya a hacer,deber铆a refactorizar)

		VIDEO 15 EXPRIME LA PROGRAMACION FUNCIONAL EN LA ARQUITECTURA HEXAGONAL

A) Forma funcional
En el front se puede hacer lo mismo que en back usando clases en hexagonal pero con funciones(incluso React dej贸 definitivamente las clases)Ojo, en Typescript las clases si que son tratadas como ciudadanos de primera clase.

Si por ejemplo vemos el caso de uso de crear un curso veo que ya estamos usando un approach funcional(con inyecci贸n de dependencias por m茅todo,ojo):

import { Course, ensureCourseIsValid } from "../../domain/Course";
import { CourseRepository } from "../../domain/CourseRepository";

export function createCourse(courseRepository: CourseRepository) {
	return async function (course: Course): Promise<void> {
		ensureCourseIsValid(course);

		await courseRepository.save(course);
	};
}


Si usaramos clases tendr铆a que inyectar por constructor el CourseRepository y habr铆a un m茅todo de clase para crear el curso,etc
Fijate que estamos llamando a una funci贸n de validaci贸n que de nuevo si estuvieramos con clases habr铆a que llamar en el constructor(en el primer punto posible),etc

En resumen:
No hay instanciaci贸n del objeto curso (es decir, no hay new Course()). El objeto que nos llega por par谩metro ya cumple con la interfaz de curso, por lo que lo 煤nico que hay que hacer es validar que las propiedades de este son correctas. Esto nos lleva al segundo punto.

Al no haber constructor, no podemos ejecutar las validaciones all铆. Por eso las tenemos en funciones separadas (en CourseId.ts, CourseTitle.ts, etc), que ejecutamos en la validaci贸n de curso y lanzamos una excepci贸n si las propiedades no son correctas:

Usar funciones dir铆a que son casi todo mejoras sobre las clases, me permite exportarlas y reutilizarlas, o tmb puedo usarlas de forma individual(en vez del objeto en el que estaban):

export type saveCourse = (course: Course) => Promise<void>;
export type getCourse = (id: string) => Promise<Course | null>;
export type getAllCourses = () => Promise<Course[]>;

Cuando dice funcion Factory a que se refiere? <- aparte de esto si que entiendo que usar el approach de arriba me hace evitar que el createCourse pudiera hacer un getCourse.En resumen, en vez de pasar un repositorio entero le pasamos solo el m茅todo que queremos

Y por 煤ltimo me permite usar 'currying' lo cual me parece superinteresante,pudiendo separar los par谩metros propios del caso de uso de sus dependencias:

* Teniendo una funci贸n externa + otra interna asi **
export function createCourse(courseRepository: CourseRepository){
	return async function(course:Course): Promise<void>{
		ensureCourseIsValid(course);
		await courseRepository.save(course)
	}
}
 puedo llamar a ambas a la vez(obviamente cada grupo de parentesis manda los argumentos a una funci贸n diferente):
 createCourse(repository)({id,title,imageUrl})

NOTA: fijate que esto antes era:
function(courseRepository,course){
	courseRepository.save(course)
}
y ahora es 
function(courseRepository){
	return function(course){
		courseRepository.save(course)
	}
}

Fijate que la segunda funci贸n podria no tener argumentos(o la primera) pero siempre voy a tener que llamar a a las dos:

export function getAllCourses(courseRepo:T) {
	return async function(){
		return courseRepo.getAll()
	}
}

const courses = await getAllCourses(instancia)(); <- es ()()
Super interesante.Investigar ejemplos interesantes de currying

NOTA: con funciones flecha es aun m谩s claro.

const soakIn = (a:string) => (b:string) => b + " " + a;
soakIn("is back")("asinto"); <- "asinto is back"

Porqu茅 usar currying:
1- poder usar inyecci贸n de dependencis en testing: por ejemplo, si tengo una funci贸n que usa una API, puedo hacer la funci贸n abstracta mediante currying y esperar la API como argumento en la curried function,de esta forma puedo testear f谩cilmente la funci贸n interna mockeando su argumento,que ser谩 esta API

Antes:
import * as api from 'whatever';
function saveData(payload:any){
	return api.save('Route',payload)
}
Despues:
import * as api from 'whatever';
import * as R from 'randa';

function _saveData(api:any,payload:any){ <- fijate que la funci贸n interna si recibe un argumento autom谩ticamente la externa lo va a recibir,si no no podria pasarlo,asinto odiador
	return api.save('Route',payload)
}

Esto puede escalar perfectamente:
unction grind(a: string) {
  return (b: string) => {
    return (c: string) => {
      return (d: string) => {
        return (a + b + c + d).shuffle()
      }
    }
  }
}
grind("Chillies")("Ginger")("Turmeric")("Coriander") // 

IMPORTANTE: en React todo Event Handler o m茅todo sint茅tico es tratado como si estuviera curried asi que en la definicion del handleChange puedo usar el evento perfectamente:


<input type="text" onChange={() => handleChange('username')} <- fijate que no le he pasado el evento

* Pero lo accedo como funcion interna por estar en React
const handleChange = (fieldName:string) => (event:any) => {
	 event.stopPropagation()
   saveField(fieldName,event.target.value)
}

React llama a los eventHandler de esta forma en el background: (event) => handldeChange(param)(event)

Performance Cost: cuando creo funciones curry creo funciones englobando a otras.En HOC no usar curry puede llevar a crear cientos de funciones adicionales,mejorando la performance.En general,es mejor usar funciones curry cuando se necesite

Curry can be used from libraries like Lodash, Folktale, Ramda, and Sanctuary in JavaScript
Desde luego la parte de React me aplica de lleno

B)Forma con POO

Casi siempre podr茅 hacer lo mismo usando OOP,aunque ahora estar谩 todo cohexionado en una clase.Fijate que han usado Value Objects, y cada Value Object llamar谩 a las funciones de validacion en en constructor(pues lo primero que tengo que hacer es validar).De esta forma no es posible crear un curso que no est茅 correctamente validado.
Fijate tmb que al validar en el constructor ya no es necesaria la validaci贸n en el m茅todo del caso de uso,pues ya se ha validado que el Course sea v谩lido(antes no era asi esto)
Tmb usan m茅todos est谩ticos para ocultar la instancia,sus value objects,etc lo cual me parece un acierto.

export class Course {
	private constructor(
		readonly id: CourseId,
		readonly title: CourseTitle,
		readonly imageUrl: ImageUrl
	  ){}

este Primitives<T> es de ellos y no se lo que hace.Fijate como el create tiene que ser publico y es mejor que sea est谩tico y como llama  a los constructores de los Value Objects.Todo claro
	public static create({id,title,imageUrl}:Primitives<Course>):Course
  	return new Course(newCourseId(id),new CourseTitle(title),new ImageUrl(imageUrl))
	}

	algunos getters,nada importante
  idValue(): string {
		return this.id.value;
	}

	titleValue(): string {
		return this.title.value;
	}

	imageUrlValue(): string {
		return this.imageUrl.value;
	}
}

Un Value Object lucir谩 asi(llama a las validaciones en su constructor).Esto es importante,siempre quiero que pete lo antes posible en una validaci贸n,asi que el constructor del Value Object es el punto adecuado

export class CourseTitle {
	static readonly MAX_COURSE_LENGTH = 40;

	constructor(readonly value: string) {
		if (!CourseTitle.isValid(value)) {
			throw new Error(CourseTitle.invalidMessage(value));
		}
	}

	public static isValid(value: string): boolean {
		return value.length > CourseTitle.MAX_COURSE_LENGTH;
	}

	public static invalidMessage(value: string): string {
		return `The title [${value}] is too long. ${CourseTitle.MAX_COURSE_LENGTH} chars is the max allowed`;
	}
}

En el front es recomendable usar la aproximaci贸n funcional por motivos obvios

C) USAR VALUE OBJECTS EN UN APPROACH FUNCIONAL

Obviamente tiene mucho sentido usar Value Objects si estoy usando clases, pero tienen sentido en el frontend?

Un Value Object es una clase que representa una propiedad y centraliza toda la l贸gica que tiene que ver con esa propiedad(hace de im谩n).Por ejemplo CourseTitle

Lo mismo se puede lograr usando programaci贸n funcional:
export const TITLE_MIN_LENGTH = 5;
export const TITLE_MAX_LENGTH = 100;

export type CourseTitle = string; <- porque crean un type??

export function isCourseTitleValid(title: string): boolean {
	return title.length >= TITLE_MIN_LENGTH && title.length <= TITLE_MAX_LENGTH;
}

export function CourseTitleNotValidError(title: string): Error {
	return new Error(`Title ${title} is not valid`);
}

Parece que tmb es importante exportar su tipo(export type CourseTitle = string) ya que asi la interface del domain no tratar谩 con primitivos directamente(esto es algo que me pregunto mucho):
export interface Course {
	id: CourseId;
	title: CourseTitle; <- es aqui donde la usar茅
	imageUrl: CourseImageUrl;
}

NOTA: parece que usar Branded Types(mis propios tipos) es algo m谩s profundo que esto
type PositiveNumber = number & {__brand:'PositiveNumber'};

function divide(a:number,b:PositiveNumber){
	return a/b;
}
function assertPositiveNumber(x:unknown): asserts x is PositiveNumber{
	if(typeof x === 'number' && x < 0){
		throw new Error('Number is not greater than zero')
	}
}

const x = 10;
assertPositiveNumber(x);
divide(100,x); <- OK! pues ha pasado la linea anterior

Los branded Types permiten controlar errores de programaci贸n mediante la prevenci贸n de valores que no cumplan ciertos criterios al ser pasados como argumentos,etc.Son una forma de c贸digo defensivo en TS y pueden asegurar validacion de tipos.Interesante

			LAST VIDEO HEXAGONAL EN EL MUNDO REAL

Simplemente ver el video cual asinto.Fijate que esta arquitectura parece bastante en base a decisiones de equipo y compleja.Ya ir茅 pillando callo con ella.
Fijate que ellos est谩n metiendo todo lo que es React en sections(es decir, en modules no puede haber nada de React).Me parece interesante tmb esta decisi贸n.
Despues en dominio no puede haber casos de uso,etc.

